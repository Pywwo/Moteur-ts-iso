{"code":"import BoxCollider from './BoxCollider';\r\nimport isoPoint from '../isoPoint';\r\nimport Cube from '../Cube';\r\nvar World = /** @class */ (function () {\r\n    function World(scene, x_width, y_width, z_width) {\r\n        this.OVERLAP_BIAS = 10;\r\n        this.forceXY = false;\r\n        this._overlap = 0;\r\n        this._maxOverlap = 0;\r\n        this._velocity1 = 0;\r\n        this._velocity2 = 0;\r\n        this._newVelocity1 = 0;\r\n        this._newVelocity2 = 0;\r\n        this._average = 0;\r\n        this._result = false;\r\n        this._total = 0;\r\n        this.checkCollision = { up: true, down: true, frontX: true, frontY: true, backX: true, backY: true };\r\n        this._scene = scene;\r\n        this.bodies = new Phaser.Structs.Set();\r\n        this.bounds = new Cube(0, 0, 0, x_width, y_width, z_width);\r\n        this.gravity = new isoPoint();\r\n    }\r\n    World.prototype.enable = function (object, children) {\r\n        if (children === void 0) { children = true; }\r\n        this.enableBody(object);\r\n    };\r\n    World.prototype.enableBody = function (object) {\r\n        if (object.body === null) {\r\n            // @ts-ignore\r\n            object.body = new BoxCollider(object);\r\n            // @ts-ignore\r\n            this.bodies.set(object.body);\r\n        }\r\n        return object;\r\n    };\r\n    World.prototype.setBounds = function (x, y, z, widthX, widthY, widthZ) {\r\n        this.bounds.setTo(x, y, z, widthX, widthY, widthZ);\r\n    };\r\n    World.prototype.computeVelocity = function (axis, body, velocity, acceleration, drag, max, delta) {\r\n        max = max || 10000;\r\n        if (axis === 1 && body.allowGravity)\r\n            velocity += ((this.gravity.x + body.gravity.x) * delta);\r\n        if (body.velocity.x !== 0 && body.type === \"basic\") {\r\n            var multiplicateur = 1;\r\n            if (body.velocity.x < 0)\r\n                multiplicateur = -1;\r\n            velocity += (delta * this.gravity.z) * multiplicateur * 0.5;\r\n            if (velocity * multiplicateur <= 0.0)\r\n                velocity = 0.0;\r\n        }\r\n        else if (axis === 2 && body.allowGravity)\r\n            velocity += ((this.gravity.y + body.gravity.y) * delta);\r\n        if (body.velocity.y !== 0 && body.type === \"basic\") {\r\n            var multiplicateur = 1;\r\n            if (body.velocity.y < 0)\r\n                multiplicateur = -1;\r\n            velocity += (delta * this.gravity.z) * multiplicateur * 0.5;\r\n            if (velocity * multiplicateur <= 0.0)\r\n                velocity = 0.0;\r\n        }\r\n        else if (axis === 3 && body.allowGravity)\r\n            velocity += (this.gravity.z + body.gravity.z) * delta;\r\n        if (acceleration) {\r\n            velocity += acceleration * delta;\r\n        }\r\n        else if (drag) {\r\n            this._drag = drag * delta;\r\n            if (velocity - this._drag > 0)\r\n                velocity -= this._drag;\r\n            else if (velocity + this._drag < 0)\r\n                velocity += this._drag;\r\n            else\r\n                velocity = 0;\r\n        }\r\n        if (velocity > max)\r\n            velocity = max;\r\n        else if (velocity < -max)\r\n            velocity = -max;\r\n        return (velocity);\r\n    };\r\n    World.prototype.separate = function (body1, body2, processCallback, callbackContext, overlapOnly) {\r\n        if (!body1.enable || !body2.enable || !this.intersects(body1, body2))\r\n            return false;\r\n        if (processCallback && processCallback.call(callbackContext, body1.sprite, body2.sprite) === false)\r\n            return false;\r\n        if (overlapOnly)\r\n            return true;\r\n        if (this.forceXY || Math.abs(this.gravity.z + body1.gravity.z) < Math.abs(this.gravity.x + body1.gravity.x) || Math.abs(this.gravity.z + body1.gravity.z) < Math.abs(this.gravity.y + body1.gravity.y))\r\n            this._result = (this.separateByKey(body1, body2, overlapOnly, \"x\") || this.separateByKey(body1, body2, overlapOnly, \"y\") || this.separateByKey(body1, body2, overlapOnly, \"z\"));\r\n        else\r\n            this._result = (this.separateByKey(body1, body2, overlapOnly, \"z\") || this.separateByKey(body1, body2, overlapOnly, \"x\") || this.separateByKey(body1, body2, overlapOnly, \"y\"));\r\n        return this._result;\r\n    };\r\n    World.prototype.intersects = function (body1, body2) {\r\n        if (body1.frontX <= body2.x)\r\n            return false;\r\n        if (body1.frontY <= body2.y)\r\n            return false;\r\n        if (body1.x >= body2.frontX)\r\n            return false;\r\n        if (body1.y >= body2.frontY)\r\n            return false;\r\n        if (body1.top <= body2.z)\r\n            return false;\r\n        if (body1.z >= body2.top)\r\n            return false;\r\n        return true;\r\n    };\r\n    World.prototype.separateByKey = function (body1, body2, overlapOnly, whatTo) {\r\n        if (body1.immovable && body2.immovable) {\r\n            return false;\r\n        }\r\n        this._overlap = 0;\r\n        var body1Delta = (whatTo === \"x\" ? body1.deltaX() : (whatTo === \"y\" ? body1.deltaY() : body1.deltaZ()));\r\n        var body2Delta = (whatTo === \"x\" ? body2.deltaX() : (whatTo === \"y\" ? body2.deltaY() : body2.deltaZ()));\r\n        var body1front = (whatTo === \"x\" ? body1.frontX : (whatTo === \"y\" ? body1.frontY : body1.top));\r\n        var body2pos = (whatTo === \"x\" ? [body2.x, body2.x] : (whatTo === \"y\" ? [body2.y, body2.y] : [body2.z, body2.top]));\r\n        var body1pos = (whatTo === \"x\" ? body1.x : (whatTo === \"y\" ? body1.y : body1.z));\r\n        var body1checkColFront = (whatTo === \"x\" ? body1.checkCollision.frontX : (whatTo === \"y\" ? body1.checkCollision.frontY : body1.checkCollision.down));\r\n        var body1checkColBack = (whatTo === \"x\" ? body1.checkCollision.backX : (whatTo === \"y\" ? body1.checkCollision.backY : body1.checkCollision.up));\r\n        var body2checkColBack = (whatTo === \"x\" ? body2.checkCollision.backX : (whatTo === \"y\" ? body2.checkCollision.backY : body2.checkCollision.up));\r\n        var body2checkColFront = (whatTo === \"x\" ? body2.checkCollision.frontX : (whatTo === \"y\" ? body2.checkCollision.frontY : body2.checkCollision.frontZ));\r\n        var body2width = (whatTo === \"x\" ? body2.widthX : (whatTo === \"y\" ? body2.widthY : 0));\r\n        var body1customSeparate = (whatTo === \"x\" ? body1.customSeparateX : (whatTo === \"y\" ? body1.customSeparateY : body1.customSeparateZ));\r\n        var body2customSeparate = (whatTo === \"x\" ? body2.customSeparateX : (whatTo === \"y\" ? body2.customSeparateY : body2.customSeparateZ));\r\n        var body1velocity = (whatTo === \"x\" ? body1.velocity.x : (whatTo === \"y\" ? body1.velocity.y : body1.velocity.z));\r\n        var body2velocity = (whatTo === \"x\" ? body2.velocity.x : (whatTo === \"y\" ? body2.velocity.y : body2.velocity.z));\r\n        if (whatTo === \"x\")\r\n            this._maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + this.OVERLAP_BIAS;\r\n        else if (whatTo === \"y\")\r\n            this._maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + this.OVERLAP_BIAS;\r\n        else if (whatTo === \"z\")\r\n            this._maxOverlap = body1.deltaAbsZ() + body2.deltaAbsZ() + this.OVERLAP_BIAS;\r\n        if (body1Delta === 0 && body2Delta === 0) {\r\n            body1.embedded = true;\r\n            body2.embedded = true;\r\n        }\r\n        else if (body1Delta > body2Delta) {\r\n            this._overlap = body1front - body2pos[0];\r\n            if ((this._overlap > this._maxOverlap) || body1checkColFront === false || body2checkColBack === false) {\r\n                this._overlap = 0;\r\n            }\r\n            else {\r\n                body1.touching.none = false;\r\n                body2.touching.none = false;\r\n                if (whatTo === \"x\") {\r\n                    body1.touching.frontX = true;\r\n                    body2.touching.backX = true;\r\n                }\r\n                else if (whatTo === \"y\") {\r\n                    body1.touching.backY = true;\r\n                    body2.touching.frontY = true;\r\n                }\r\n                else if (whatTo === \"z\") {\r\n                    body1.touching.down = true;\r\n                    body2.touching.up = true;\r\n                }\r\n            }\r\n        }\r\n        else if (body1Delta < body2Delta) {\r\n            this._overlap = body1pos - body2width - body2pos[1];\r\n            if ((-this._overlap > this._maxOverlap) || body1checkColBack === false || body2checkColFront === false) {\r\n                this._overlap = 0;\r\n            }\r\n            else {\r\n                body1.touching.none = false;\r\n                body2.touching.none = false;\r\n                if (whatTo === \"x\") {\r\n                    body1.touching.backX = true;\r\n                    body2.touching.frontX = true;\r\n                }\r\n                else if (whatTo === \"y\") {\r\n                    body1.touching.backY = true;\r\n                    body2.touching.frontY = true;\r\n                }\r\n                else if (whatTo === \"z\") {\r\n                    body1.touching.up = true;\r\n                    body2.touching.down = true;\r\n                }\r\n            }\r\n        }\r\n        if (this._overlap !== 0) {\r\n            if (whatTo === \"x\") {\r\n                body1.overlapX = this._overlap;\r\n                body2.overlapX = this._overlap;\r\n            }\r\n            else if (whatTo === \"y\") {\r\n                body1.overlapY = this._overlap;\r\n                body2.overlapY = this._overlap;\r\n            }\r\n            else if (whatTo === \"z\") {\r\n                body1.overlapZ = this._overlap;\r\n                body2.overlapZ = this._overlap;\r\n            }\r\n            if (overlapOnly || body1customSeparate || body2customSeparate)\r\n                return true;\r\n            this._velocity1 = body1velocity;\r\n            this._velocity2 = body2velocity;\r\n            if (!body1.immovable && !body2.immovable) {\r\n                //test\r\n                // this._overlap *= 0.5;\r\n                if (whatTo === \"x\") {\r\n                    body1.x = body1.x - this._overlap;\r\n                    body2.x += this._overlap;\r\n                }\r\n                else if (whatTo === \"y\") {\r\n                    body1.y = body1.y - this._overlap;\r\n                    body2.y += this._overlap;\r\n                }\r\n                else if (whatTo === \"z\") {\r\n                    body1.z = body1.z - this._overlap;\r\n                    body2.z += this._overlap;\r\n                }\r\n                this._newVelocity1 = Math.sqrt((this._velocity2 * this._velocity2 * body2.mass) / body1.mass) * ((this._velocity2 > 0) ? 1 : -1);\r\n                this._newVelocity2 = Math.sqrt((this._velocity1 * this._velocity1 * body1.mass) / body2.mass) * ((this._velocity1 > 0) ? 1 : -1);\r\n                this._average = (this._newVelocity1 + this._newVelocity2) * 0.5;\r\n                this._newVelocity1 -= this._average;\r\n                this._newVelocity2 -= this._average;\r\n                if (whatTo === \"x\") {\r\n                    body1.velocity.x = this._average + this._newVelocity1 * body1.bounce.x;\r\n                    body2.velocity.x = this._average + this._newVelocity2 * body2.bounce.x;\r\n                }\r\n                else if (whatTo === \"y\") {\r\n                    body1.velocity.y = this._average + this._newVelocity1 * body1.bounce.y;\r\n                    body2.velocity.y = this._average + this._newVelocity2 * body2.bounce.y;\r\n                }\r\n                else if (whatTo === \"z\") {\r\n                    body1.velocity.z = this._average + this._newVelocity1 * body1.bounce.z;\r\n                    body2.velocity.z = this._average + this._newVelocity2 * body2.bounce.z;\r\n                }\r\n            }\r\n            else if (!body1.immovable) {\r\n                if (whatTo === \"x\") {\r\n                    body1.x = body1.x - this._overlap;\r\n                    body1.velocity.x = this._velocity2 - this._velocity1 * body1.bounce.x;\r\n                }\r\n                else if (whatTo === \"y\") {\r\n                    body1.y = body1.y - this._overlap;\r\n                    body1.velocity.y = this._velocity2 - this._velocity1 * body1.bounce.y;\r\n                }\r\n                else if (whatTo === \"z\") {\r\n                    body1.z = body1.z - this._overlap;\r\n                    body1.velocity.z = this._velocity2 - this._velocity1 * body1.bounce.z;\r\n                }\r\n                //addd moves\r\n            }\r\n            else if (!body2.immovable) {\r\n                if (whatTo === \"x\") {\r\n                    body2.x += this._overlap;\r\n                    body2.velocity.x = this._velocity1 - this._velocity2 * body2.bounce.x;\r\n                }\r\n                else if (whatTo === \"y\") {\r\n                    body2.y += this._overlap;\r\n                    body2.velocity.y = this._velocity1 - this._velocity2 * body2.bounce.y;\r\n                }\r\n                else if (whatTo === \"z\") {\r\n                    body2.z += this._overlap;\r\n                    body2.velocity.z = this._velocity1 - this._velocity2 * body2.bounce.z;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    World.prototype.collide = function (object1, collideCallback, processCallback, callbackContext) {\r\n        if (collideCallback === void 0) { collideCallback = null; }\r\n        if (processCallback === void 0) { processCallback = null; }\r\n        callbackContext = callbackContext || collideCallback;\r\n        this._result = false;\r\n        this._total = 0;\r\n        this.collideGroupVsSelf(object1, collideCallback, processCallback, callbackContext, false);\r\n        return (this._total > 0);\r\n    };\r\n    World.prototype.collideSpriteVsSprite = function (sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {\r\n        if (!sprite1.body || !sprite2.body) {\r\n            return false;\r\n        }\r\n        if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {\r\n            if (collideCallback)\r\n                collideCallback.call(callbackContext, sprite1, sprite2);\r\n            this._total++;\r\n        }\r\n        return true;\r\n    };\r\n    World.prototype.collideGroupVsSelf = function (group, collideCallback, processCallback, callbackContext, overlapOnly) {\r\n        if (group.children.size === 0) {\r\n            return;\r\n        }\r\n        for (var i = 0; i < group.children.size; i++) {\r\n            for (var j = i + 1; j <= group.children.size; j++) {\r\n                var entries = group.children.entries;\r\n                if (entries[i] && entries[j])\r\n                    this.collideSpriteVsSprite(entries[i], entries[j], collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n    };\r\n    World.prototype.updateMotion = function (body, delta) {\r\n        body.angularVelocity += this.computeVelocity(0, body, body.angularVelocity, body.angularAcceleration, body.angularDrag, body.maxAngular, delta) - body.angularVelocity;\r\n        body.rotation += (body.angularVelocity * delta);\r\n        body.velocity.x = this.computeVelocity(1, body, body.velocity.x, body.acceleration.x, body.drag.x, body.maxVelocity.x, delta);\r\n        body.velocity.y = this.computeVelocity(2, body, body.velocity.y, body.acceleration.y, body.drag.y, body.maxVelocity.y, delta);\r\n        body.velocity.z = this.computeVelocity(3, body, body.velocity.z, body.acceleration.z, body.drag.z, body.maxVelocity.z, delta);\r\n    };\r\n    World.prototype.update = function (time, delta) {\r\n        var bodies = this.bodies.entries;\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            if (bodies[i].enable)\r\n                bodies[i].update(time, delta);\r\n        }\r\n    };\r\n    World.prototype.postUpdate = function () {\r\n        var bodies = this.bodies.entries;\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            if (bodies[i].enable)\r\n                bodies[i].postUpdate();\r\n        }\r\n    };\r\n    return World;\r\n}());\r\nexport default World;\r\n","references":["/home/Pywwo/projet_libre/moteur_ts_iso/src/mon-plugin/world/BoxCollider.ts","/home/Pywwo/projet_libre/moteur_ts_iso/src/mon-plugin/isoPoint.ts","/home/Pywwo/projet_libre/moteur_ts_iso/src/mon-plugin/Cube.ts","/home/Pywwo/projet_libre/moteur_ts_iso/src/mon-plugin/isoSprite.ts"]}
