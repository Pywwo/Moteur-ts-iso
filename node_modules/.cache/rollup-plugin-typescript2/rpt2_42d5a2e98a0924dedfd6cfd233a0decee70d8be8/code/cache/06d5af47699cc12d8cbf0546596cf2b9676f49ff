{"code":"import BoxCollider from './BoxCollider';\r\nimport isoPoint from '../isoPoint';\r\nimport Cube from '../Cube';\r\nvar ISOSPRITE = 'IsoSprite';\r\nvar GameObjects = Phaser.GameObjects, Structs = Phaser.Structs;\r\nvar World = /** @class */ (function () {\r\n    function World(scene, width, height) {\r\n        this.checkCollision = {\r\n            up: true,\r\n            down: true,\r\n            frontX: true,\r\n            frontY: true,\r\n            backX: true,\r\n            backY: true\r\n        };\r\n        this._scene = scene;\r\n        this._width = width;\r\n        this._height = height;\r\n        this.bodies = new Structs.Set();\r\n        this.bounds = new Cube(0, 0, 0, width * 0.5, width * 0.5, height);\r\n        this.gravity = new isoPoint();\r\n        this.OVERLAP_BIAS = 10;\r\n        this.forceXY = false;\r\n        this._overlap = 0;\r\n        this._maxOverlap = 0;\r\n        this._velocity1 = 0;\r\n        this._velocity2 = 0;\r\n        this._newVelocity1 = 0;\r\n        this._newVelocity2 = 0;\r\n        this._average = 0;\r\n        this._result = false;\r\n        this._total = 0;\r\n    }\r\n    World.prototype.enable = function (object, children) {\r\n        if (children === void 0) { children = true; }\r\n        var i = 1;\r\n        if (Array.isArray(object)) {\r\n            i = object.length;\r\n            while (i--) {\r\n                if (object[i] instanceof GameObjects.Group) {\r\n                    this.enable(object[i].children, children);\r\n                }\r\n                else {\r\n                    this.enableBody(object[i]);\r\n                    if (children && object[i].hasOwnProperty('children') && object[i].children.length > 0) {\r\n                        this.enable(object[i], true);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (object instanceof GameObjects.Group) {\r\n            this.enable(object.children, children);\r\n        }\r\n        else {\r\n            this.enableBody(object);\r\n            if (children && object.hasOwnProperty('children') && object.children.length > 0) {\r\n                this.enable(object.children, true);\r\n            }\r\n        }\r\n    };\r\n    World.prototype.enableBody = function (object) {\r\n        if (object.body === null) {\r\n            object.body = new BoxCollider(object);\r\n            this.bodies.set(object.body);\r\n        }\r\n        return object;\r\n    };\r\n    World.prototype.setBounds = function (x, y, z, widthX, widthY, height) {\r\n        this.bounds.setTo(x, y, z, widthX, widthY, height);\r\n    };\r\n    World.prototype.setBoundsToWorld = function () {\r\n        this.bounds.setTo(0, 0, 0, this._width * 0.5, this._width * 0.5, this._height);\r\n    };\r\n    World.prototype.computeVelocity = function (axis, body, velocity, acceleration, drag, max, delta) {\r\n        max = max || 10000;\r\n        if (axis === 1 && body.allowGravity) {\r\n            velocity += (this.gravity.x + body.gravity.x) * delta;\r\n        }\r\n        else if (axis === 2 && body.allowGravity) {\r\n            velocity += (this.gravity.y + body.gravity.y) * delta;\r\n        }\r\n        else if (axis === 3 && body.allowGravity) {\r\n            velocity += (this.gravity.z + body.gravity.z) * delta;\r\n        }\r\n        if (acceleration) {\r\n            velocity += acceleration * delta;\r\n        }\r\n        else if (drag) {\r\n            this._drag = drag * delta;\r\n            if (velocity - this._drag > 0) {\r\n                velocity -= this._drag;\r\n            }\r\n            else if (velocity + this._drag < 0) {\r\n                velocity += this._drag;\r\n            }\r\n            else {\r\n                velocity = 0;\r\n            }\r\n        }\r\n        if (velocity > max) {\r\n            velocity = max;\r\n        }\r\n        else if (velocity < -max) {\r\n            velocity = -max;\r\n        }\r\n        return velocity;\r\n    };\r\n    World.prototype.separate = function (body1, body2, processCallback, callbackContext, overlapOnly) {\r\n        if (!body1.enable || !body2.enable || !this.intersects(body1, body2)) {\r\n            return false;\r\n        }\r\n        if (processCallback && processCallback.call(callbackContext, body1.sprite, body2.sprite) === false) {\r\n            return false;\r\n        }\r\n        if (overlapOnly) {\r\n            return true;\r\n        }\r\n        if (this.forceXY || Math.abs(this.gravity.z + body1.gravity.z) < Math.abs(this.gravity.x + body1.gravity.x) || Math.abs(this.gravity.z + body1.gravity.z) < Math.abs(this.gravity.y + body1.gravity.y)) {\r\n            this._result = (this.separateX(body1, body2, overlapOnly) || this.separateY(body1, body2, overlapOnly) || this.separateZ(body1, body2, overlapOnly));\r\n        }\r\n        else {\r\n            this._result = (this.separateZ(body1, body2, overlapOnly) || this.separateX(body1, body2, overlapOnly) || this.separateY(body1, body2, overlapOnly));\r\n        }\r\n        return this._result;\r\n    };\r\n    World.prototype.intersects = function (body1, body2) {\r\n        if (body1.frontX <= body2.x) {\r\n            return false;\r\n        }\r\n        if (body1.frontY <= body2.y) {\r\n            return false;\r\n        }\r\n        if (body1.x >= body2.frontX) {\r\n            return false;\r\n        }\r\n        if (body1.y >= body2.frontY) {\r\n            return false;\r\n        }\r\n        if (body1.top <= body2.z) {\r\n            return false;\r\n        }\r\n        if (body1.z >= body2.top) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    World.prototype.separateX = function (body1, body2, overlapOnly) {\r\n        if (body1.immovable && body2.immovable) {\r\n            return false;\r\n        }\r\n        this._overlap = 0;\r\n        this._maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + this.OVERLAP_BIAS;\r\n        if (body1.deltaX() === 0 && body2.deltaX() === 0) {\r\n            body1.embedded = true;\r\n            body2.embedded = true;\r\n        }\r\n        else if (body1.deltaX() > body2.deltaX()) {\r\n            this._overlap = body1.frontX - body2.x;\r\n            if ((this._overlap > this._maxOverlap) || body1.checkCollision.frontX === false || body2.checkCollision.backX === false) {\r\n                this._overlap = 0;\r\n            }\r\n            else {\r\n                body1.touching.none = false;\r\n                body1.touching.frontX = true;\r\n                body2.touching.none = false;\r\n                body2.touching.backX = true;\r\n            }\r\n        }\r\n        else if (body1.deltaX() < body2.deltaX()) {\r\n            this._overlap = body1.x - body2.widthX - body2.x;\r\n            if ((-this._overlap > this._maxOverlap) || body1.checkCollision.backX === false || body2.checkCollision.frontX === false) {\r\n                this._overlap = 0;\r\n            }\r\n            else {\r\n                body1.touching.none = false;\r\n                body1.touching.backX = true;\r\n                body2.touching.none = false;\r\n                body2.touching.frontX = true;\r\n            }\r\n        }\r\n        if (this._overlap !== 0) {\r\n            body1.overlapX = this._overlap;\r\n            body2.overlapX = this._overlap;\r\n            if (overlapOnly || body1.customSeparateX || body2.customSeparateX) {\r\n                return true;\r\n            }\r\n            this._velocity1 = body1.velocity.x;\r\n            this._velocity2 = body2.velocity.x;\r\n            if (!body1.immovable && !body2.immovable) {\r\n                this._overlap *= 0.5;\r\n                body1.x = body1.x - this._overlap;\r\n                body2.x += this._overlap;\r\n                this._newVelocity1 = Math.sqrt((this._velocity2 * this._velocity2 * body2.mass) / body1.mass) * ((this._velocity2 > 0) ? 1 : -1);\r\n                this._newVelocity2 = Math.sqrt((this._velocity1 * this._velocity1 * body1.mass) / body2.mass) * ((this._velocity1 > 0) ? 1 : -1);\r\n                this._average = (this._newVelocity1 + this._newVelocity2) * 0.5;\r\n                this._newVelocity1 -= this._average;\r\n                this._newVelocity2 -= this._average;\r\n                body1.velocity.x = this._average + this._newVelocity1 * body1.bounce.x;\r\n                body2.velocity.x = this._average + this._newVelocity2 * body2.bounce.x;\r\n            }\r\n            else if (!body1.immovable) {\r\n                body1.x = body1.x - this._overlap;\r\n                body1.velocity.x = this._velocity2 - this._velocity1 * body1.bounce.x;\r\n            }\r\n            else if (!body2.immovable) {\r\n                body2.x += this._overlap;\r\n                body2.velocity.x = this._velocity1 - this._velocity2 * body2.bounce.x;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    World.prototype.separateY = function (body1, body2, overlapOnly) {\r\n        if (body1.immovable && body2.immovable) {\r\n            return false;\r\n        }\r\n        this._overlap = 0;\r\n        this._maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + this.OVERLAP_BIAS;\r\n        if (body1.deltaY() === 0 && body2.deltaY() === 0) {\r\n            body1.embedded = true;\r\n            body2.embedded = true;\r\n        }\r\n        else if (body1.deltaY() > body2.deltaY()) {\r\n            this._overlap = body1.frontY - body2.y;\r\n            if ((this._overlap > this._maxOverlap) || body1.checkCollision.frontY === false || body2.checkCollision.backY === false) {\r\n                this._overlap = 0;\r\n            }\r\n            else {\r\n                body1.touching.none = false;\r\n                body1.touching.frontY = true;\r\n                body2.touching.none = false;\r\n                body2.touching.backY = true;\r\n            }\r\n        }\r\n        else if (body1.deltaY() < body2.deltaY()) {\r\n            this._overlap = body1.y - body2.widthY - body2.y;\r\n            if ((-this._overlap > this._maxOverlap) || body1.checkCollision.backY === false || body2.checkCollision.frontY === false) {\r\n                this._overlap = 0;\r\n            }\r\n            else {\r\n                body1.touching.none = false;\r\n                body1.touching.backY = true;\r\n                body2.touching.none = false;\r\n                body2.touching.frontY = true;\r\n            }\r\n        }\r\n        if (this._overlap !== 0) {\r\n            body1.overlapY = this._overlap;\r\n            body2.overlapY = this._overlap;\r\n            if (overlapOnly || body1.customSeparateY || body2.customSeparateY) {\r\n                return true;\r\n            }\r\n            this._velocity1 = body1.velocity.y;\r\n            this._velocity2 = body2.velocity.y;\r\n            if (!body1.immovable && !body2.immovable) {\r\n                this._overlap *= 0.5;\r\n                body1.y = body1.y - this._overlap;\r\n                body2.y += this._overlap;\r\n                this._newVelocity1 = Math.sqrt((this._velocity2 * this._velocity2 * body2.mass) / body1.mass) * ((this._velocity2 > 0) ? 1 : -1);\r\n                this._newVelocity2 = Math.sqrt((this._velocity1 * this._velocity1 * body1.mass) / body2.mass) * ((this._velocity1 > 0) ? 1 : -1);\r\n                this._average = (this._newVelocity1 + this._newVelocity2) * 0.5;\r\n                this._newVelocity1 -= this._average;\r\n                this._newVelocity2 -= this._average;\r\n                body1.velocity.y = this._average + this._newVelocity1 * body1.bounce.y;\r\n                body2.velocity.y = this._average + this._newVelocity2 * body2.bounce.y;\r\n            }\r\n            else if (!body1.immovable) {\r\n                body1.y = body1.y - this._overlap;\r\n                body1.velocity.y = this._velocity2 - this._velocity1 * body1.bounce.y;\r\n            }\r\n            else if (!body2.immovable) {\r\n                body2.y += this._overlap;\r\n                body2.velocity.y = this._velocity1 - this._velocity2 * body2.bounce.y;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    World.prototype.separateZ = function (body1, body2, overlapOnly) {\r\n        if (body1.immovable && body2.immovable) {\r\n            return false;\r\n        }\r\n        this._overlap = 0;\r\n        this._maxOverlap = body1.deltaAbsZ() + body2.deltaAbsZ() + this.OVERLAP_BIAS;\r\n        if (body1.deltaZ() === 0 && body2.deltaZ() === 0) {\r\n            body1.embedded = true;\r\n            body2.embedded = true;\r\n        }\r\n        else if (body1.deltaZ() > body2.deltaZ()) {\r\n            this._overlap = body1.top - body2.z;\r\n            if ((this._overlap > this._maxOverlap) || body1.checkCollision.down === false || body2.checkCollision.up === false) {\r\n                this._overlap = 0;\r\n            }\r\n            else {\r\n                body1.touching.none = false;\r\n                body1.touching.down = true;\r\n                body2.touching.none = false;\r\n                body2.touching.up = true;\r\n            }\r\n        }\r\n        else if (body1.deltaZ() < body2.deltaZ()) {\r\n            //  Body1 is moving up and/or Body2 is moving down\r\n            this._overlap = body1.z - body2.top;\r\n            if ((-this._overlap > this._maxOverlap) || body1.checkCollision.up === false || body2.checkCollision.down === false) {\r\n                this._overlap = 0;\r\n            }\r\n            else {\r\n                body1.touching.none = false;\r\n                body1.touching.up = true;\r\n                body2.touching.none = false;\r\n                body2.touching.down = true;\r\n            }\r\n        }\r\n        if (this._overlap !== 0) {\r\n            body1.overlapZ = this._overlap;\r\n            body2.overlapZ = this._overlap;\r\n            if (overlapOnly || body1.customSeparateY || body2.customSeparateZ) {\r\n                return true;\r\n            }\r\n            this._velocity1 = body1.velocity.z;\r\n            this._velocity2 = body2.velocity.z;\r\n            if (!body1.immovable && !body2.immovable) {\r\n                this._overlap *= 0.5;\r\n                body1.z = body1.z - this._overlap;\r\n                body2.z += this._overlap;\r\n                this._newVelocity1 = Math.sqrt((this._velocity2 * this._velocity2 * body2.mass) / body1.mass) * ((this._velocity2 > 0) ? 1 : -1);\r\n                this._newVelocity2 = Math.sqrt((this._velocity1 * this._velocity1 * body1.mass) / body2.mass) * ((this._velocity1 > 0) ? 1 : -1);\r\n                this._average = (this._newVelocity1 + this._newVelocity2) * 0.5;\r\n                this._newVelocity1 -= this._average;\r\n                this._newVelocity2 -= this._average;\r\n                body1.velocity.z = this._average + this._newVelocity1 * body1.bounce.z;\r\n                body2.velocity.z = this._average + this._newVelocity2 * body2.bounce.z;\r\n            }\r\n            else if (!body1.immovable) {\r\n                body1.z = body1.z - this._overlap;\r\n                body1.velocity.z = this._velocity2 - this._velocity1 * body1.bounce.z;\r\n                if (body2.moves) {\r\n                    body1.x += body2.x - body2.prev.x;\r\n                    body1.y += body2.y - body2.prev.y;\r\n                }\r\n            }\r\n            else if (!body2.immovable) {\r\n                body2.z += this._overlap;\r\n                body2.velocity.z = this._velocity1 - this._velocity2 * body2.bounce.z;\r\n                if (body1.moves) {\r\n                    body2.x += body1.x - body1.prev.x;\r\n                    body2.y += body1.y - body1.prev.y;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    World.prototype.collide = function (object1, object2, collideCallback, processCallback, callbackContext) {\r\n        if (collideCallback === void 0) { collideCallback = null; }\r\n        if (processCallback === void 0) { processCallback = null; }\r\n        callbackContext = callbackContext || collideCallback;\r\n        this._result = false;\r\n        this._total = 0;\r\n        this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, false);\r\n        return (this._total > 0);\r\n    };\r\n    World.prototype.collideHandler = function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {\r\n        //  Only collide valid objects\r\n        if (!object2 && object1.type === 'Group') {\r\n            this.collideGroupVsSelf(object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n        }\r\n    };\r\n    World.prototype.collideSpriteVsSprite = function (sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {\r\n        if (!sprite1.body || !sprite2.body) {\r\n            return false;\r\n        }\r\n        if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {\r\n            if (collideCallback) {\r\n                collideCallback.call(callbackContext, sprite1, sprite2);\r\n            }\r\n            this._total++;\r\n        }\r\n        return true;\r\n    };\r\n    World.prototype.collideGroupVsSelf = function (group, collideCallback, processCallback, callbackContext, overlapOnly) {\r\n        if (group.children.size === 0) {\r\n            return;\r\n        }\r\n        var len = group.children.size;\r\n        for (var i = 0; i < len; i++) {\r\n            for (var j = i + 1; j <= len; j++) {\r\n                var entries = group.children.entries;\r\n                var spriteOne = entries[i];\r\n                var spriteTwo = entries[j];\r\n                if (spriteOne && spriteTwo) {\r\n                    this.collideSpriteVsSprite(spriteOne, spriteTwo, collideCallback, processCallback, callbackContext, overlapOnly);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    World.prototype.updateMotion = function (body, delta) {\r\n        this._velocityDelta = this.computeVelocity(0, body, body.angularVelocity, body.angularAcceleration, body.angularDrag, body.maxAngular, delta) - body.angularVelocity;\r\n        body.angularVelocity += this._velocityDelta;\r\n        body.rotation += (body.angularVelocity * delta);\r\n        body.velocity.x = this.computeVelocity(1, body, body.velocity.x, body.acceleration.x, body.drag.x, body.maxVelocity.x, delta);\r\n        body.velocity.y = this.computeVelocity(2, body, body.velocity.y, body.acceleration.y, body.drag.y, body.maxVelocity.y, delta);\r\n        body.velocity.z = this.computeVelocity(3, body, body.velocity.z, body.acceleration.z, body.drag.z, body.maxVelocity.z, delta);\r\n    };\r\n    World.prototype.update = function (time, delta) {\r\n        var bodies = this.bodies.entries;\r\n        var len = bodies.length;\r\n        var i;\r\n        for (i = 0; i < len; i++) {\r\n            var body = bodies[i];\r\n            if (body.enable) {\r\n                bodies[i].update(time, delta);\r\n            }\r\n        }\r\n    };\r\n    World.prototype.postUpdate = function () {\r\n        var bodies = this.bodies.entries;\r\n        var len = bodies.length;\r\n        var i;\r\n        for (i = 0; i < len; i++) {\r\n            var body = bodies[i];\r\n            if (body.enable) {\r\n                body.postUpdate();\r\n            }\r\n        }\r\n    };\r\n    return World;\r\n}());\r\nexport default World;\r\n","references":["/home/Pywwo/projet_libre/experience-phaser-isoetric-plugin/src/mon-plugin/world/BoxCollider.ts","/home/Pywwo/projet_libre/experience-phaser-isoetric-plugin/src/mon-plugin/isoPoint.ts","/home/Pywwo/projet_libre/experience-phaser-isoetric-plugin/src/mon-plugin/Cube.ts"]}
